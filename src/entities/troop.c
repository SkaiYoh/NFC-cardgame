//
// Created by Nathan Davis on 2/16/26.
//

#include "troop.h"
#include "entities.h"
#include "../../lib/cJSON.h"
#include <stdio.h>
#include <string.h>

TroopData troop_create_data_from_card(const Card *card) {
    TroopData data = {0};
    data.name = card->name;
    data.spriteType = sprite_type_from_card(card->type);

    // Sensible defaults
    data.hp = 100;
    data.maxHP = 100;
    data.attack = 10;
    data.attackSpeed = 1.0f;
    data.attackRange = 40.0f;
    data.moveSpeed = 60.0f;
    data.targeting = TARGET_NEAREST;
    data.targetType = NULL;

    // Override from card JSON data if available
    if (!card->data) return data;

    cJSON *root = cJSON_Parse(card->data);
    if (!root) return data;

    cJSON *hp = cJSON_GetObjectItem(root, "hp");
    if (hp && cJSON_IsNumber(hp)) {
        data.hp = hp->valueint;
        data.maxHP = hp->valueint;
    }

    cJSON *maxHP = cJSON_GetObjectItem(root, "maxHP");
    if (maxHP && cJSON_IsNumber(maxHP)) {
        data.maxHP = maxHP->valueint;
    }

    cJSON *atk = cJSON_GetObjectItem(root, "attack");
    if (atk && cJSON_IsNumber(atk)) {
        data.attack = atk->valueint;
    }

    cJSON *atkSpd = cJSON_GetObjectItem(root, "attackSpeed");
    if (atkSpd && cJSON_IsNumber(atkSpd)) {
        data.attackSpeed = (float)atkSpd->valuedouble;
    }

    cJSON *atkRange = cJSON_GetObjectItem(root, "attackRange");
    if (atkRange && cJSON_IsNumber(atkRange)) {
        data.attackRange = (float)atkRange->valuedouble;
    }

    cJSON *spd = cJSON_GetObjectItem(root, "moveSpeed");
    if (spd && cJSON_IsNumber(spd)) {
        data.moveSpeed = (float)spd->valuedouble;
    }

    cJSON *tgt = cJSON_GetObjectItem(root, "targeting");
    if (tgt && cJSON_IsString(tgt)) {
        if (strcmp(tgt->valuestring, "building") == 0)
            data.targeting = TARGET_BUILDING;
        else if (strcmp(tgt->valuestring, "specific") == 0)
            data.targeting = TARGET_SPECIFIC_TYPE;
    }

    cJSON *tgtType = cJSON_GetObjectItem(root, "targetType");
    if (tgtType && cJSON_IsString(tgtType)) {
        // TODO: CRITICAL â€” data.targetType is assigned a pointer into the cJSON tree. cJSON_Delete
        // TODO: immediately below frees the tree, making this pointer dangling. Any read of
        // TODO: data.targetType after this function returns is undefined behavior.
        // TODO: Fix: data.targetType = strdup(tgtType->valuestring); and free it in the caller.
        data.targetType = tgtType->valuestring;
    }

    cJSON_Delete(root);
    return data;
}

Entity *troop_spawn(Player *owner, const TroopData *data, Vector2 position,
                    const SpriteAtlas *atlas) {
    Faction faction = (owner->id == 0) ? FACTION_PLAYER1 : FACTION_PLAYER2;
    Entity *e = entity_create(ENTITY_TROOP, faction, position);
    if (!e) return NULL;

    // Stats
    e->hp = data->hp;
    e->maxHP = data->maxHP;
    e->attack = data->attack;
    e->attackSpeed = data->attackSpeed;
    e->attackRange = data->attackRange;
    e->moveSpeed = data->moveSpeed;

    // Ownership
    e->ownerID = owner->id;
    // TODO: e->lane is never set here. The slot index used by spawn_troop_from_card to choose a
    // TODO: spawn position is not propagated to Entity.lane, breaking all lane-based targeting logic.
    // TODO: Pass the chosen slot index into troop_spawn and assign e->lane = slotIndex.

    // Sprite
    e->sprite = sprite_atlas_get(atlas, data->spriteType);

    // Start walking immediately
    entity_set_state(e, ESTATE_WALKING);

    printf("[TROOP] Spawned '%s' (id=%d) for player %d at (%.0f, %.0f)\n",
           data->name, e->id, owner->id, position.x, position.y);

    return e;
}
